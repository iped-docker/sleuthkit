diff --git a/bindings/java/jni/dataModel_SleuthkitJNI.cpp b/bindings/java/jni/dataModel_SleuthkitJNI.cpp
index 908c709..1141278 100644
--- a/bindings/java/jni/dataModel_SleuthkitJNI.cpp
+++ b/bindings/java/jni/dataModel_SleuthkitJNI.cpp
@@ -150,6 +150,17 @@
     return lcl;
 }
 
+static TSK_IMG_INFO *
+castImgOrPoolInfo(JNIEnv * env, jlong ptr)
+{
+	TSK_IMG_INFO *lcl = (TSK_IMG_INFO *)ptr;
+	if (!lcl || (lcl->tag != TSK_IMG_INFO_TAG && lcl->tag != TSK_POOL_INFO_TAG)) {
+		setThrowTskCoreError(env, "Invalid IMG_INFO/POOL_INFO object");
+		return 0;
+	}
+	return lcl;
+}
+
 static TSK_FS_INFO *
 castFsInfo(JNIEnv * env, jlong ptr)
 {
@@ -159,7 +170,7 @@
         return 0;
     }
     // verify that image handle is still open
-    if (!castImgInfo(env, (jlong) lcl->img_info)) {
+    if (!castImgOrPoolInfo(env, (jlong) lcl->img_info)) {
         return 0;
     }
     return lcl;
@@ -1412,6 +1423,9 @@
     return (jlong) vol_part_info;
 }
 
+//lock used for opening apfs files from multiple threads
+static tsk_lock_t * apfs_read_lock = (tsk_lock_t *)tsk_malloc(sizeof(tsk_lock_t));
+static bool lockInited = false;
 
 /*
  * Open file system with the given offset
@@ -1422,17 +1436,38 @@
  * @param fs_offset the offset in bytes to the file system 
  */
 JNIEXPORT jlong JNICALL Java_org_sleuthkit_datamodel_SleuthkitJNI_openFsNat
-    (JNIEnv * env, jclass obj, jlong a_img_info, jlong fs_offset) {
+    (JNIEnv * env, jclass obj, jlong caseHandle, jlong a_img_info, jlong fs_offset) {
     TSK_IMG_INFO *img_info = castImgInfo(env, a_img_info);
     if (img_info == 0) {
         //exception already set
         return 0;
     }
-    TSK_FS_INFO *fs_info;
 
-    fs_info =
-        tsk_fs_open_img(img_info, (TSK_OFF_T) fs_offset,
-        TSK_FS_TYPE_DETECT);
+	TskCaseDb *tskCase = castCaseDb(env, caseHandle);
+	if (tskCase == 0) {
+		//exception already set
+		return 0;
+	}
+
+	//cast ok?
+	TSK_DADDR_T pool_block = (TSK_DADDR_T)fs_offset;
+	DB_POOL_INFO pool_info = tskCase->getTskDb()->getPoolInfo(pool_block);
+	TSK_FS_INFO *fs_info;
+
+	if (pool_info.pool_block == 0) {
+		//tsk_fprintf(stdout, "\ngetPoolInfo() returned no result for block %d\n", pool_info.pool_block);
+		fs_info = tsk_fs_open_img(img_info, (TSK_OFF_T)fs_offset, TSK_FS_TYPE_DETECT);
+	}
+	else {
+		fs_info = tsk_fs_open_img2(pool_info, img_info, TSK_FS_TYPE_DETECT);
+		
+		//init apfs lock
+		if (!lockInited) {
+			tsk_init_lock(apfs_read_lock);
+			lockInited = true;
+		}
+	}
+
     if (fs_info == NULL) {
         setThrowTskCoreError(env, tsk_error_get());
     }
@@ -1460,18 +1495,31 @@
         return 0;
     }
 
-    
+	bool apfs_locked = false;
+	if (fs_info->pool_info->tag == TSK_POOL_INFO_TAG) {
+		tsk_take_lock(apfs_read_lock);
+		apfs_locked = true;
+	}
+
     TSK_FS_FILE *file_info;
     //open file
     file_info = tsk_fs_file_open_meta(fs_info, NULL, (TSK_INUM_T) file_id);
     if (file_info == NULL) {
         setThrowTskCoreError(env, tsk_error_get());
+		if (apfs_locked) {
+			tsk_release_lock(apfs_read_lock);
+		}
         return 0;
     }
-
+	
     //open attribute
-    const TSK_FS_ATTR * tsk_fs_attr = 
-        tsk_fs_file_attr_get_type(file_info, (TSK_FS_ATTR_TYPE_ENUM)attr_type, (uint16_t)attr_id, 1);
+	const TSK_FS_ATTR * tsk_fs_attr =
+		tsk_fs_file_attr_get_type(file_info, (TSK_FS_ATTR_TYPE_ENUM)attr_type, (uint16_t)attr_id, 1);
+
+	if (apfs_locked) {
+		tsk_release_lock(apfs_read_lock);
+	}
+
     if (tsk_fs_attr == NULL) {
         tsk_fs_file_close(file_info);
         setThrowTskCoreError(env, tsk_error_get());
diff --git a/bindings/java/jni/dataModel_SleuthkitJNI.h b/bindings/java/jni/dataModel_SleuthkitJNI.h
index 52a7a85..83ef390 100644
--- a/bindings/java/jni/dataModel_SleuthkitJNI.h
+++ b/bindings/java/jni/dataModel_SleuthkitJNI.h
@@ -293,7 +293,7 @@
  * Signature: (JJ)J
  */
 JNIEXPORT jlong JNICALL Java_org_sleuthkit_datamodel_SleuthkitJNI_openFsNat
-  (JNIEnv *, jclass, jlong, jlong);
+  (JNIEnv *, jclass, jlong, jlong, jlong);
 
 /*
  * Class:     org_sleuthkit_datamodel_SleuthkitJNI
diff --git a/bindings/java/src/org/sleuthkit/datamodel/SleuthkitJNI.java b/bindings/java/src/org/sleuthkit/datamodel/SleuthkitJNI.java
index 142d980..c47922c 100644
--- a/bindings/java/src/org/sleuthkit/datamodel/SleuthkitJNI.java
+++ b/bindings/java/src/org/sleuthkit/datamodel/SleuthkitJNI.java
@@ -833,7 +833,7 @@
 					//return cached
 					fsHandle = imgOffSetToFsHandle.get(fsOffset);
 				} else {
-					fsHandle = openFsNat(imgHandle, fsOffset);
+					fsHandle = openFsNat(caseDbPointer, imgHandle, fsOffset);
 					//cache it
 					imgOffSetToFsHandle.put(fsOffset, fsHandle);
 				}
@@ -1659,7 +1659,7 @@
 
 	private static native long openVolNat(long vsHandle, long volId) throws TskCoreException;
 
-	private static native long openFsNat(long imgHandle, long fsId) throws TskCoreException;
+	private static native long openFsNat(long db, long imgHandle, long fsId) throws TskCoreException;
 
 	private static native long openFileNat(long fsHandle, long fileId, int attrType, int attrId) throws TskCoreException;
 
diff --git a/bindings/java/src/org/sleuthkit/datamodel/TskData.java b/bindings/java/src/org/sleuthkit/datamodel/TskData.java
index 6c8b844..9ba3bb6 100644
--- a/bindings/java/src/org/sleuthkit/datamodel/TskData.java
+++ b/bindings/java/src/org/sleuthkit/datamodel/TskData.java
@@ -301,7 +301,13 @@
 		TSK_FS_ATTR_TYPE_HFS_DATA(0x1100), // 4352 Data fork of regular files
 		TSK_FS_ATTR_TYPE_HFS_RSRC(0x1101), // 4353 Resource fork of regular files
 		TSK_FS_ATTR_TYPE_HFS_EXT_ATTR(0x1102), // 4354 Extended Attributes) except compression records
-		TSK_FS_ATTR_TYPE_HFS_COMP_REC(0x1103); // 4355 Compression records
+		TSK_FS_ATTR_TYPE_HFS_COMP_REC(0x1103), // 4355 Compression records
+	    
+	    // Types for APFS File Attributes (alias to HFS+)
+	    TSK_FS_ATTR_TYPE_APFS_DATA(0x1100),
+	    TSK_FS_ATTR_TYPE_APFS_RSRC(0x1101),
+	    TSK_FS_ATTR_TYPE_APFS_EXT_ATTR(0x1102),
+	    TSK_FS_ATTR_TYPE_APFS_COMP_REC(0x1103);
 
 		private int val;
 
@@ -455,11 +461,14 @@
 		TSK_FS_TYPE_RAW_DETECT(0x00000400, bundle.getString("TskData.tskFsTypeEnum.RAWautoDetect")), ///< RAW auto detection
 		TSK_FS_TYPE_ISO9660(0x00000800, "ISO9660"), ///< ISO9660 file system
 		TSK_FS_TYPE_ISO9660_DETECT(0x00000800, bundle.getString("TskData.tskFsTypeEnum.ISO9660autoDetect")), ///< ISO9660 auto detection
-		TSK_FS_TYPE_HFS(0x00001000, "HFS"), ///< HFS file system
-		TSK_FS_TYPE_HFS_DETECT(0x00001000, bundle.getString("TskData.tskFsTypeEnum.HFSautoDetect")), ///< HFS auto detection
+		TSK_FS_TYPE_HFS(0x00001000, "HFS"), ///< HFS+/HFSX file system
+		TSK_FS_TYPE_HFS_DETECT(0x00009000, bundle.getString("TskData.tskFsTypeEnum.HFSautoDetect")), ///< HFS auto detection
 		TSK_FS_TYPE_EXT4(0x00002000, "Ext4"), ///< Ext4 file system
 		TSK_FS_TYPE_YAFFS2(0x00004000, "YAFFS2"), ///< YAFFS2 file system
 		TSK_FS_TYPE_YAFFS2_DETECT(0x00004000, bundle.getString("TskData.tskFsTypeEnum.YAFFS2autoDetect")), ///< YAFFS2 auto detection
+		TSK_FS_TYPE_HFS_LEGACY(0x00008000, "HFS (legacy)"),   ///< HFS file system
+		TSK_FS_TYPE_APFS(0x00010000, "APFS"), ///< APFS file system
+        TSK_FS_TYPE_APFS_DETECT(0x00010000, "APFS (Auto Detection)"), ///< APFS auto detection
 		TSK_FS_TYPE_UNSUPP(0xffffffff, bundle.getString("TskData.tskFsTypeEnum.unsupported"));        ///< Unsupported file system
 
 		private int value;
diff --git a/tools/autotools/tsk_loaddb.cpp b/tools/autotools/tsk_loaddb.cpp
index b59506d..a75f855 100644
--- a/tools/autotools/tsk_loaddb.cpp
+++ b/tools/autotools/tsk_loaddb.cpp
@@ -11,6 +11,7 @@
 
 #include "tsk/tsk_tools_i.h"
 #include "tsk/auto/tsk_case_db.h"
+#include "tsk/fs/apfs_fs.h"
 #include <locale.h>
 
 static TSK_TCHAR *progname;
@@ -29,6 +30,12 @@
         "\t-i imgtype: The format of the image file (use '-i list' for supported types)\n");
     tsk_fprintf(stderr,
         "\t-b dev_sector_size: The size (in bytes) of the device sectors\n");
+	tsk_fprintf(stderr,
+		"\t-P pooltype: Pool container type (use '-P list' for supported types)\n");
+	tsk_fprintf(stderr,
+		"\t-B pool_volume_block: Starting block (for pool volumes only)\n");
+	tsk_fprintf(stderr, "\t-S snap_id: Snapshot ID (for APFS only)\n");
+	tsk_fprintf(stderr, "\t-K password: Decryption password for encrypted volumes\n");
     tsk_fprintf(stderr, "\t-d database: Path for the database (default is the same directory as the image, with name derived from image name)\n");
     tsk_fprintf(stderr, "\t-v: verbose output to stderr\n");
     tsk_fprintf(stderr, "\t-V: Print version\n");
@@ -54,6 +61,11 @@
     bool createDbFlag = true; // true if we are going to create a new database
     bool calcHash = false;
 
+	const char *password = "";
+	TSK_POOL_TYPE_ENUM pooltype = TSK_POOL_TYPE_DETECT;
+	TSK_DADDR_T pvol_block = 0;
+	TSK_DADDR_T snap_id = 0;
+
 #ifdef TSK_WIN32
     // On Windows, get the wide arguments (mingw doesn't support wmain)
     argv = CommandLineToArgvW(GetCommandLineW(), &argc);
@@ -68,7 +80,7 @@
     progname = argv[0];
     setlocale(LC_ALL, "");
 
-    while ((ch = GETOPT(argc, argv, _TSK_T("ab:d:hi:kvVz:"))) > 0) {
+    while ((ch = GETOPT(argc, argv, _TSK_T("ab:d:hi:kvVz:P:B:K:S:"))) > 0) {
         switch (ch) {
         case _TSK_T('?'):
         default:
@@ -104,7 +116,36 @@
             }
             break;
                 
-        case _TSK_T('k'):
+		case _TSK_T('P'):
+			if (TSTRCMP(OPTARG, _TSK_T("list")) == 0) {
+				tsk_pool_type_print(stderr);
+				exit(1);
+			}
+			pooltype = tsk_pool_type_toid(OPTARG);
+			if (pooltype == TSK_POOL_TYPE_UNSUPP) {
+				TFPRINTF(stderr,
+					_TSK_T("Unsupported pool container type: %s\n"), OPTARG);
+				usage();
+			}
+			break;
+		case _TSK_T('B'):
+			if ((pvol_block = tsk_parse_offset(OPTARG)) == -1) {
+				tsk_error_print(stderr);
+				exit(1);
+			}
+			break;
+		case _TSK_T('S'):
+			if ((snap_id = tsk_parse_offset(OPTARG)) == -1) {
+				tsk_error_print(stderr);
+				exit(1);
+			}
+			break;
+		
+		case _TSK_T('K'):
+			password = argv1[OPTIND - 1];
+			break;
+		
+		case _TSK_T('k'):
             blkMapFlag = false;
             break;
 
@@ -171,7 +212,9 @@
     TskAutoDb *autoDb = tskCase->initAddImage();
     autoDb->createBlockMap(blkMapFlag);
     autoDb->hashFiles(calcHash);
-    autoDb->setAddUnallocSpace(true);
+	//IPED PATCH
+	autoDb->setAddUnallocSpace(true, 500 * 1024 * 1024);
+	autoDb->setPassword(password);
 
     if (autoDb->startAddImage(argc - OPTIND, &argv[OPTIND], imgtype, ssize)) {
         std::vector<TskAuto::error_record> errors = autoDb->getErrorList();
diff --git a/tsk/auto/auto.cpp b/tsk/auto/auto.cpp
index 9d71b4d..1759442 100644
--- a/tsk/auto/auto.cpp
+++ b/tsk/auto/auto.cpp
@@ -16,6 +16,7 @@
 #include "tsk_auto_i.h"
 #include "tsk/fs/tsk_fatxxfs.h"
 #include "tsk/img/img_writer.h"
+#include "tsk/fs/apfs_fs.h"
 
 
 // @@@ Follow through some error paths for sanity check and update docs somewhere to reflect the new scheme
@@ -32,6 +33,7 @@
     m_curVsPartDescr = "";
     m_imageWriterEnabled = false;
     m_imageWriterPath = NULL;
+	password = "";
 }
 
 
@@ -62,6 +64,10 @@
 bool TskAuto::isCurVsValid() const {
     return m_curVsPartValid;
 }
+
+void TskAuto::setPassword(const char * pass){
+	password = pass;
+}
 
 /**
  * Opens the disk image to be analyzed.  This must be called before any
@@ -355,34 +361,72 @@
     }
 
     TSK_FS_INFO *fs_info;
-    if ((fs_info = tsk_fs_open_img(m_img_info, a_start, a_ftype)) == NULL) {
-        if (isCurVsValid() == false) {
-            tsk_error_set_errstr2 ("Sector offset: %" PRIuOFF, a_start/512);
-            registerError();
-            return TSK_ERR;
-        }
-        else if (getCurVsPartFlag() & TSK_VS_PART_FLAG_ALLOC) {
-            tsk_error_set_errstr2 (
-                "Sector offset: %" PRIuOFF ", Partition Type: %s",
-                a_start/512, getCurVsPartDescr().c_str()
-            );
-            registerError();
-            return TSK_ERR;
-        }
-        else {
-            tsk_error_reset();
-            return TSK_OK;
-        }
-    }
+	TSK_RETVAL_ENUM retval;
+	const TSK_POOL_INFO *pool = NULL;
 
-    TSK_RETVAL_ENUM retval = findFilesInFsInt(fs_info, fs_info->root_inum);
-    tsk_fs_close(fs_info);
+	pool = tsk_pool_open_img_sing(m_img_info, a_start, TSK_POOL_TYPE_DETECT);
+	if (pool == NULL) {
+		//no apfs code path
+		if ((fs_info = tsk_fs_open_img(m_img_info, a_start, a_ftype)) == NULL) {
+			if (isCurVsValid() == false) {
+				tsk_error_set_errstr2("Sector offset: %" PRIuOFF, a_start / 512);
+				registerError();
+				return TSK_ERR;
+			}
+			else if (getCurVsPartFlag() & TSK_VS_PART_FLAG_ALLOC) {
+				tsk_error_set_errstr2(
+					"Sector offset: %" PRIuOFF ", Partition Type: %s",
+					a_start / 512, getCurVsPartDescr().c_str()
+				);
+				registerError();
+				return TSK_ERR;
+			}
+			else {
+				tsk_error_reset();
+				return TSK_OK;
+			}
+		}
+		else {
+			retval = findFilesInFsInt(fs_info, fs_info->root_inum);
+			tsk_fs_close(fs_info);
+		}
+	}
+	else {
+		TSK_POOL_VOLUME_INFO *tpvi = pool->vol_list;
+		while (tpvi != NULL) {
+
+			TSK_DADDR_T pvol_block = tpvi->block;
+			//tsk_fprintf(stdout, "\nDecoding pvol_block %d\n", pvol_block);
+
+			if ((fs_info = tsk_fs_open_pool_decrypt(pool, pvol_block, a_ftype, password)) == NULL) {
+				tsk_error_print(stderr);
+				if (tsk_error_get_errno() == TSK_ERR_FS_UNSUPTYPE)
+					tsk_fs_type_print(stderr);
+				tsk_fprintf(stderr, "\nInvalid fs in apsb_block %d of pool at %d\n", pvol_block, a_start);
+			}
+			else {
+				TskAuto *tsk = (TskAuto *)this;
+				tsk->addPoolInfo(pvol_block, a_start);
+
+				retval = findFilesInFsInt(fs_info, fs_info->root_inum);
+				tsk_fs_close(fs_info);
+			}
+
+			tpvi = tpvi->next;
+		}
+		pool->close(pool);
+	}
+
     if (m_errors.empty() == false)
         return TSK_ERR;
     else 
         return retval;
 }
 
+void TskAuto::addPoolInfo(TSK_DADDR_T pool_block, TSK_OFF_T img_offset)
+{
+}
+
 
 /**
  * Starts in a specified byte offset of the opened disk images and looks for a
diff --git a/tsk/auto/auto_db.cpp b/tsk/auto/auto_db.cpp
index 3323b50..4e2d10e 100644
--- a/tsk/auto/auto_db.cpp
+++ b/tsk/auto/auto_db.cpp
@@ -317,6 +317,14 @@
     return TSK_FILTER_CONT;
 }
 
+/**
+* @returns 1 on error, 0 on success
+*/
+void
+TskAutoDb::addPoolInfo(TSK_DADDR_T pool_block, TSK_OFF_T img_offset)
+{
+	m_db->addPoolInfo(pool_block, img_offset, this->password);
+}
 
 TSK_FILTER_ENUM
 TskAutoDb::filterFs(TSK_FS_INFO * fs_info)
diff --git a/tsk/auto/case_db.cpp b/tsk/auto/case_db.cpp
index 700649a..45badef 100644
--- a/tsk/auto/case_db.cpp
+++ b/tsk/auto/case_db.cpp
@@ -44,6 +44,11 @@
     m_tag = 0;
 }
 
+TskDb *
+TskCaseDb::getTskDb() {
+	return m_db;
+}
+
 /**
 * Creates a new single-user case with a new database and initializes its tables.
 * Fails if there's already a file at the given path.
diff --git a/tsk/auto/db_sqlite.cpp b/tsk/auto/db_sqlite.cpp
index b041c1a..82732e4 100644
--- a/tsk/auto/db_sqlite.cpp
+++ b/tsk/auto/db_sqlite.cpp
@@ -12,6 +12,8 @@
 * \file db_sqlite.cpp
 * Contains code to perform operations against SQLite database. 
 */
+//IPED PATCH
+#include "tsk_case_db.h"
 
 #include "tsk_db_sqlite.h"
 #include "guid.h"
@@ -300,6 +302,10 @@
         ("CREATE TABLE tsk_fs_info (obj_id INTEGER PRIMARY KEY, img_offset INTEGER NOT NULL, fs_type INTEGER NOT NULL, block_size INTEGER NOT NULL, block_count INTEGER NOT NULL, root_inum INTEGER NOT NULL, first_inum INTEGER NOT NULL, last_inum INTEGER NOT NULL, display_name TEXT, FOREIGN KEY(obj_id) REFERENCES tsk_objects(obj_id));",
         "Error creating tsk_fs_info table: %s\n")
         ||
+		attempt_exec
+		("CREATE TABLE tsk_pool_info (pool_block INTEGER PRIMARY KEY, img_offset INTEGER NOT NULL, password TEXT);",
+			"Error creating tsk_pool_info table: %s\n")
+		||
         attempt_exec
         ("CREATE TABLE data_source_info (obj_id INTEGER PRIMARY KEY, device_id TEXT NOT NULL,  time_zone TEXT NOT NULL, acquisition_details TEXT, FOREIGN KEY(obj_id) REFERENCES tsk_objects(obj_id));",
         "Error creating data_source_info table: %s\n")
@@ -495,12 +501,30 @@
     // enable finer result codes
     sqlite3_extended_result_codes(m_db, true);
 
+	//IPED PATCH
+	if (attempt_exec("PRAGMA synchronous = OFF;",
+		"Error setting PRAGMA synchronous: %s\n")) {
+		return 1;
+	}
+	if (attempt_exec("PRAGMA busy_timeout = 3600000;",
+		"Error setting PRAGMA busy_timeout: %s\n")) {
+		return 1;
+	}
+	if (attempt_exec("PRAGMA cache_size = 4000;",
+		"Error setting PRAGMA cache_size: %s\n")) {
+		return 1;
+	}
+
     // create the tables if we need to
     if (a_toInit) {
         if (initialize())
             return 1;
     }
 
+	//IPED PATCH: cria indice para colunas consultadas em findParObjId
+	attempt_exec("CREATE INDEX findParent1 ON tsk_files(meta_addr, fs_obj_id, parent_path, name);",
+		"Error creating findParent1 index on tsk_files: %s\n");
+
     if (setupFilePreparedStmt()) {
         return 1;
     }
@@ -716,6 +740,62 @@
         "Error adding data to tsk_fs_info table: %s\n");
 }
 
+/**
+* @returns 1 on error, 0 on success
+*/
+int
+TskDbSqlite::addPoolInfo(TSK_DADDR_T pool_block, TSK_OFF_T img_offset, const char *password)
+{
+	char
+		stmt[1024];
+
+	snprintf(stmt, 1024,
+		"INSERT INTO tsk_pool_info (pool_block, img_offset, password) "
+		"VALUES (%" PRIuDADDR ",%" PRIuOFF ", '%s')", 
+		pool_block, img_offset, password);
+	
+	return attempt_exec(stmt,
+		"Error adding data to tsk_pool_info table: %s\n");
+}
+
+DB_POOL_INFO TskDbSqlite::getPoolInfo(TSK_DADDR_T pool_block) {
+
+	DB_POOL_INFO rowData;
+	//error code
+	rowData.pool_block = 0;
+
+	//tsk_fprintf(stdout, "\ngetPoolInfo() called for block %d\n", pool_block);
+
+	sqlite3_stmt * stmt = NULL;
+	if (prepare_stmt("SELECT * from tsk_pool_info where pool_block IS ?", &stmt)
+		|| attempt(sqlite3_bind_int64(stmt, 1, pool_block), 
+		"TskDbSqlite::getPoolInfo: Error binding pool_block to statement: %s (result code %d)\n")) {
+		return rowData;
+	}
+
+	//get rows
+	if (sqlite3_step(stmt) == SQLITE_ROW) {
+
+		rowData.pool_block = sqlite3_column_int64(stmt, 0);
+		rowData.img_offset = sqlite3_column_int64(stmt, 1);
+		const unsigned char * text = sqlite3_column_text(stmt, 2);
+		size_t textLen = sqlite3_column_bytes(stmt, 2);
+		strncpy(rowData.password, (char*)text, textLen);
+		rowData.password[textLen] = '\0';
+
+		//tsk_fprintf(stdout, "\ngetPoolInfo() result offset =  %d\n", rowData.img_offset);
+	}
+
+	//cleanup
+	if (stmt != NULL) {
+		sqlite3_finalize(stmt);
+		stmt = NULL;
+	}
+
+	return rowData;
+}
+
+
 // ?????
 //int TskDbSqlite::addCarvedFile(TSK_FS_FILE * fs_file,
 //    const TSK_FS_ATTR * fs_attr, const char *path, int64_t fsObjId, int64_t parObjId, int64_t & objId)
@@ -724,6 +804,10 @@
 //    return addFile(fs_file, fs_attr, path, fsObjId, parObjId, objId);
 //}
 
+//IPED PATCH
+int num_files = 0;
+int NUM_FILES_TO_COMMIT = 10000;
+int NUM_UNALLOC_TO_COMMIT = 100;
 
 /**
 * Add a file system file to the database
@@ -764,7 +848,15 @@
         }    
     }
 
-    return addFile(fs_file, fs_attr, path, md5, known, fsObjId, parObjId, objId, dataSourceObjId);
+	//IPED PATCH
+	int result = addFile(fs_file, fs_attr, path, md5, known, fsObjId, parObjId, objId, dataSourceObjId);
+
+	if (++num_files % NUM_FILES_TO_COMMIT == 0) {
+		releaseSavepoint(TSK_ADD_IMAGE_SAVEPOINT);
+		createSavepoint(TSK_ADD_IMAGE_SAVEPOINT);
+	}
+
+	return result;
 }
 
 
@@ -891,6 +983,10 @@
         || attempt(sqlite3_step(m_selectFilePreparedStmt), SQLITE_ROW,
         "TskDbSqlite::findParObjId: Error selecting file id by meta_addr: %s (result code %d)\n"))
     {
+		//IPED patch: print missed files
+		fprintf(stderr, "Miss2: %s (%" PRIu64 " - %" PRIu64 ")\n", fs_file->name->name, fs_file->name->meta_addr,
+			fs_file->name->par_addr);
+
         // Statement may be used again, even after error
         sqlite3_reset(m_selectFilePreparedStmt);
         return -1;
@@ -1521,6 +1617,12 @@
             }
     }
 
+	//IPED PATCH
+	if (++num_files % NUM_UNALLOC_TO_COMMIT == 0) {
+		releaseSavepoint(TSK_ADD_IMAGE_SAVEPOINT);
+		createSavepoint(TSK_ADD_IMAGE_SAVEPOINT);
+	}
+
     return TSK_OK;
 }
 
diff --git a/tsk/auto/tsk_auto.h b/tsk/auto/tsk_auto.h
index 7ada263..582d5be 100644
--- a/tsk/auto/tsk_auto.h
+++ b/tsk/auto/tsk_auto.h
@@ -75,6 +75,8 @@
     virtual uint8_t openImageHandle(TSK_IMG_INFO *);
     virtual void closeImage();
 
+	virtual void addPoolInfo(TSK_DADDR_T pool_block, TSK_OFF_T img_offset);
+
     TSK_OFF_T getImageSize() const;
     /**
      * Returns true if all processing and recursion should stop. 
@@ -211,6 +213,8 @@
      * therefore we can trust the results of getCurVsPartFlag/Desc.
      */
     bool isCurVsValid() const;
+
+	void setPassword(const char *pass);
     
   private:
     TSK_VS_PART_FLAG_ENUM m_volFilterFlags;
@@ -253,6 +257,7 @@
 	bool m_imageWriterEnabled;
     TSK_TCHAR * m_imageWriterPath;
 
+	const char *password;
     
     TSK_RETVAL_ENUM processAttributes(TSK_FS_FILE * fs_file,
         const char *path);
diff --git a/tsk/auto/tsk_case_db.h b/tsk/auto/tsk_case_db.h
index 851c577..47e4771 100644
--- a/tsk/auto/tsk_case_db.h
+++ b/tsk/auto/tsk_case_db.h
@@ -44,7 +44,8 @@
     virtual void setTz(string tzone);
 
     virtual TSK_FILTER_ENUM filterVs(const TSK_VS_INFO * vs_info);
-    virtual TSK_FILTER_ENUM filterVol(const TSK_VS_PART_INFO * vs_part);
+    virtual TSK_FILTER_ENUM filterVol(const TSK_VS_PART_INFO * vs_part);
+    virtual void addPoolInfo(TSK_DADDR_T pool_block, TSK_OFF_T img_offset);
     virtual TSK_FILTER_ENUM filterFs(TSK_FS_INFO * fs_info);
     virtual TSK_RETVAL_ENUM processFile(TSK_FS_FILE * fs_file,
         const char *path);
@@ -216,6 +217,8 @@
         TSK_IMG_TYPE_ENUM imgType, unsigned int sSize);
     TskAutoDb *initAddImage();
 
+	TskDb *getTskDb();
+
   private:
     // prevent copying until we add proper logic to handle it
     TskCaseDb(const TskCaseDb&);
diff --git a/tsk/auto/tsk_db.h b/tsk/auto/tsk_db.h
index 47816e7..cf5dc7e 100644
--- a/tsk/auto/tsk_db.h
+++ b/tsk/auto/tsk_db.h
@@ -175,6 +175,7 @@
     virtual int addVsInfo(const TSK_VS_INFO * vs_info, int64_t parObjId, int64_t & objId) = 0;
     virtual int addVolumeInfo(const TSK_VS_PART_INFO * vs_part, int64_t parObjId, int64_t & objId) = 0;
     virtual int addFsInfo(const TSK_FS_INFO * fs_info, int64_t parObjId, int64_t & objId) = 0;
+	virtual int addPoolInfo(TSK_DADDR_T pool_block, TSK_OFF_T img_offset, const char *password) = 0;
     virtual int addFsFile(TSK_FS_FILE * fs_file, const TSK_FS_ATTR * fs_attr,
         const char *path, const unsigned char *const md5,
         const TSK_DB_FILES_KNOWN_ENUM known, int64_t fsObjId,
@@ -211,6 +212,8 @@
     virtual TSK_RETVAL_ENUM getParentImageId (const int64_t objId, int64_t & imageId) = 0;
     virtual TSK_RETVAL_ENUM getFsRootDirObjectInfo(const int64_t fsObjId, TSK_DB_OBJECT & rootDirObjInfo) = 0;
 
+	virtual DB_POOL_INFO getPoolInfo(TSK_DADDR_T pool_block) = 0;
+
   protected:
 	
 	  /**
diff --git a/tsk/auto/tsk_db_sqlite.h b/tsk/auto/tsk_db_sqlite.h
index 9aeab07..3606593 100644
--- a/tsk/auto/tsk_db_sqlite.h
+++ b/tsk/auto/tsk_db_sqlite.h
@@ -52,7 +52,8 @@
     int addVolumeInfo(const TSK_VS_PART_INFO * vs_part, int64_t parObjId,
         int64_t & objId);
     int addFsInfo(const TSK_FS_INFO * fs_info, int64_t parObjId,
-        int64_t & objId);
+        int64_t & objId);
+	int addPoolInfo(TSK_DADDR_T pool_block, TSK_OFF_T img_offset, const char * password);
     int addFsFile(TSK_FS_FILE * fs_file, const TSK_FS_ATTR * fs_attr,
         const char *path, const unsigned char *const md5,
         const TSK_DB_FILES_KNOWN_ENUM known, int64_t fsObjId,
@@ -87,6 +88,7 @@
     TSK_RETVAL_ENUM getParentImageId (const int64_t objId, int64_t & imageId);
     TSK_RETVAL_ENUM getFsRootDirObjectInfo(const int64_t fsObjId, TSK_DB_OBJECT & rootDirObjInfo);
 
+	DB_POOL_INFO getPoolInfo(TSK_DADDR_T pool_block);
 
   private:
     // prevent copying until we add proper logic to handle it
diff --git a/tsk/base/tsk_base.h b/tsk/base/tsk_base.h
index a913811..12da67c 100644
--- a/tsk/base/tsk_base.h
+++ b/tsk/base/tsk_base.h
@@ -43,7 +43,7 @@
 
 /** Version of code in string form. See TSK_VERSION_NUM for
  * integer form. */
-#define TSK_VERSION_STR "4.6.5"
+#define TSK_VERSION_STR "4.6.5-iped-patch01"
 
 
 /* include the TSK-specific header file that we created in autoconf
diff --git a/tsk/fs/fs_open.c b/tsk/fs/fs_open.c
index d5d2ca0..10527c7 100644
--- a/tsk/fs/fs_open.c
+++ b/tsk/fs/fs_open.c
@@ -25,6 +25,7 @@
  --*/
 
 #include "tsk_fs_i.h"
+#include "tsk/fs/apfs_fs.h"
 
 /**
  * \file fs_open.c
@@ -101,9 +102,47 @@
  */
 TSK_FS_INFO *
 tsk_fs_open_img(TSK_IMG_INFO * a_img_info, TSK_OFF_T a_offset,
-    TSK_FS_TYPE_ENUM a_ftype)
+	TSK_FS_TYPE_ENUM a_ftype)
 {
-    return tsk_fs_open_img_decrypt(a_img_info, a_offset, a_ftype, "");
+	TSK_FS_INFO *fs_info = tsk_fs_open_img_decrypt(a_img_info, a_offset, a_ftype, "");
+	return fs_info;
+}
+
+TSK_FS_INFO *
+tsk_fs_open_img2(DB_POOL_INFO pool_info , TSK_IMG_INFO * a_img_info, TSK_FS_TYPE_ENUM a_ftype)
+{
+	TSK_FS_INFO *fs_info;
+
+	TSK_POOL_TYPE_ENUM pooltype = TSK_POOL_TYPE_DETECT;
+	const TSK_POOL_INFO *pool = NULL;
+
+	TSK_OFF_T a_offset = pool_info.img_offset;
+
+	//tsk_fprintf(stdout, "\nOpening pool at offset %d\n", a_offset);
+
+	pool = tsk_pool_open_img_sing(a_img_info, a_offset, pooltype);
+	if (pool == NULL) {
+		tsk_error_print(stderr);
+		if (tsk_error_get_errno() == TSK_ERR_FS_UNSUPTYPE)
+			tsk_fs_type_print(stderr);
+		//m_img_info->close(m_img_info);
+		//exit(1);
+		tsk_fprintf(stderr, "\nInvalid pool at %d\n", a_offset);
+		return TSK_COR;
+	}
+
+	if (pool_info.pool_block != 0) {
+		//tsk_fprintf(stdout, "\nDecoding pvol_block %d\n", pool_info.pool_block);
+
+		if ((fs_info = tsk_fs_open_pool_decrypt(pool, pool_info.pool_block, a_ftype, pool_info.password)) == NULL) {
+			tsk_error_print(stderr);
+			if (tsk_error_get_errno() == TSK_ERR_FS_UNSUPTYPE)
+				tsk_fs_type_print(stderr);
+			tsk_fprintf(stderr, "\nInvalid fs in apsb_block %d of pool at offset %d\n", pool_info.pool_block, a_offset);
+		}
+	}
+	
+	return fs_info;
 }
 
 /**
diff --git a/tsk/fs/tsk_fs.h b/tsk/fs/tsk_fs.h
index 6e1dcc8..923e709 100644
--- a/tsk/fs/tsk_fs.h
+++ b/tsk/fs/tsk_fs.h
@@ -1030,6 +1030,7 @@
     /* File system level */
     extern TSK_FS_INFO *tsk_fs_open_img(TSK_IMG_INFO *, TSK_OFF_T,
         TSK_FS_TYPE_ENUM);
+	extern TSK_FS_INFO *tsk_fs_open_img2(DB_POOL_INFO pool_info, TSK_IMG_INFO * a_img_info, TSK_FS_TYPE_ENUM a_ftype);
     extern TSK_FS_INFO *tsk_fs_open_vol(const TSK_VS_PART_INFO *,
         TSK_FS_TYPE_ENUM);
     extern TSK_FS_INFO *tsk_fs_open_pool(const TSK_POOL_INFO *,
diff --git a/tsk/img/tsk_img.h b/tsk/img/tsk_img.h
index 131f23c..98278c2 100644
--- a/tsk/img/tsk_img.h
+++ b/tsk/img/tsk_img.h
@@ -75,6 +75,14 @@
 #define TSK_IMG_INFO_CACHE_NUM  32
 #define TSK_IMG_INFO_CACHE_LEN  65536
 
+	typedef struct DB_POOL_INFO DB_POOL_INFO;
+
+	struct DB_POOL_INFO {
+		TSK_DADDR_T pool_block;
+		TSK_OFF_T img_offset;
+		char password[256];
+	};
+
     typedef struct TSK_IMG_INFO TSK_IMG_INFO;
 #define TSK_IMG_INFO_TAG 0x39204231
 
